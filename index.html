<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Quick Blur â€“ Clipboard In/Out</title>
  <meta name="theme-color" content="#0b0c0f">
  <link rel="manifest" href="manifest.json">
  <link rel="icon" href="icons/icon-192.png">
  <style>
    :root { --bg:#0b0c0f; --panel:#151821; --text:#e8eaf0; --muted:#a9b0be; --acc:#4aa8ff; }
    html,body{height:100%;}
    body{margin:0; background:linear-gradient(180deg,#0b0c0f,#0e1016); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;}
    header{display:flex; align-items:center; gap:12px; padding:14px 16px; background:#0e121a; border-bottom:1px solid #1f2430; position:sticky; top:0; z-index:10}
    header h1{font-size:16px; margin:0; font-weight:600; letter-spacing:.2px}
    .toolbar{display:flex; flex-wrap:wrap; gap:8px; align-items:center;}
    .btn{background:var(--panel); color:var(--text); border:1px solid #2a3140; border-radius:12px; padding:10px 12px; cursor:pointer; font-weight:600}
    .btn:hover{border-color:#3a4356}
    .btn:disabled{opacity:.5; cursor:not-allowed}
    .kbd{border:1px solid #2a3140; background:#0b0d13; padding:2px 6px; border-radius:6px; font-size:12px; color:var(--muted)}
    .sep{width:1px; height:28px; background:#252b39; margin:0 6px}
    .slider{appearance:none; height:6px; border-radius:999px; background:#2a3140; outline:none}
    .slider::-webkit-slider-thumb{appearance:none; width:18px; height:18px; border-radius:50%; background:var(--acc); border:none}
    label{font-size:13px; color:var(--muted)}
    #wrap{display:grid; grid-template-columns: 320px 1fr; gap:12px; height:calc(100% - 64px)}
    aside{padding:12px; border-right:1px solid #1f2430; background:#0e121a}
    main{display:flex; align-items:center; justify-content:center; position:relative;}
    canvas{max-width:100%; max-height:calc(100vh - 120px); background:#111416; border-radius:16px; box-shadow:0 10px 40px rgba(0,0,0,.35);}
    .hint{font-size:13px; color:var(--muted); line-height:1.6}
    .pill{display:inline-block; padding:4px 8px; border-radius:999px; background:#121623; border:1px solid #242a39; color:var(--muted); font-size:12px;}
    .row{display:flex; align-items:center; justify-content:space-between; gap:8px; margin:8px 0}
    .row > div{display:flex; align-items:center; gap:8px}
    .radio{display:flex; gap:8px}
    .radio label{display:flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid #2a3140; border-radius:10px; cursor:pointer;}
    .radio input{accent-color:var(--acc)}
    footer{position:fixed; right:16px; bottom:16px; background:#0f131b; border:1px solid #202637; color:var(--muted); padding:10px 12px; border-radius:12px; font-size:12px}
    .ghost{opacity:.5}
  </style>
</head>
<body>
  <header>
    <h1>ã‚¯ã‚¤ãƒƒã‚¯ã¼ã‹ã—ãƒ„ãƒ¼ãƒ« â€“ ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰å¯¾å¿œ</h1>
    <div class="toolbar">
      <button id="pasteBtn" class="btn">ğŸ“‹ ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‹ã‚‰è²¼ã‚Šä»˜ã‘ <span class="kbd">âŒ˜/Ctrl+V</span></button>
      <button id="openBtn" class="btn">ğŸ“‚ ç”»åƒã‚’é–‹ã</button>
      <input id="file" type="file" accept="image/*" hidden>
      <div class="sep"></div>
      <button id="copyBtn" class="btn" disabled>ğŸ“¤ ç”»åƒã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã¸ <span class="kbd">âŒ˜/Ctrl+C</span></button>
      <button id="downloadBtn" class="btn" disabled>ğŸ’¾ PNGä¿å­˜</button>
      <div class="sep"></div>
      <button id="undoBtn" class="btn" disabled>â†¶ å…ƒã«æˆ»ã™ <span class="kbd">âŒ˜/Ctrl+Z</span></button>
      <button id="resetBtn" class="btn" disabled>ğŸ§¹ ãƒªã‚»ãƒƒãƒˆ</button>
    </div>
  </header>

  <div id="wrap">
    <aside>
      <div class="row"><label>ãƒ–ãƒ©ã‚·ã‚µã‚¤ã‚º: <span id="brushSizeVal" class="pill">36 px</span></label></div>
      <input id="brushSize" class="slider" type="range" min="6" max="200" step="2" value="36"/>
      <div class="row"><label>ã¼ã‹ã—å¼·ã•: <span id="blurVal" class="pill">12 px</span></label></div>
      <input id="blurRadius" class="slider" type="range" min="2" max="50" step="1" value="12"/>

      <div class="row"><label>ãƒ¢ãƒ¼ãƒ‰</label></div>
      <div class="radio">
        <label><input type="radio" name="mode" value="blur" checked> ã¼ã‹ã—</label>
        <label><input type="radio" name="mode" value="pixelate"> ãƒ¢ã‚¶ã‚¤ã‚¯</label>
        <label><input type="radio" name="mode" value="erase"> æ¶ˆã—ã‚´ãƒ </label>
      </div>

      <hr style="border-color:#1f2430; border-width:1px; border-style:solid; margin:12px 0"/>
      <div class="hint">
        <div>ğŸ“Œ <b>ä½¿ã„æ–¹</b></div>
        <ul>
          <li>ç”»åƒã‚’ <b>è²¼ã‚Šä»˜ã‘</b>ï¼ˆ<span class="kbd">âŒ˜/Ctrl+V</span>ï¼‰ã¾ãŸã¯ã€Œç”»åƒã‚’é–‹ãã€ã€‚</li>
          <li>ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã§ <b>ãƒ‰ãƒ©ãƒƒã‚°</b>ã—ã¦é¡”ã‚’å¡—ã‚‹ã¨ã€ãã®éƒ¨åˆ†ã ã‘ãŒã¼ã‹ã•ã‚Œã¾ã™ã€‚</li>
          <li>ãƒ–ãƒ©ã‚·ã‚µã‚¤ã‚ºãƒ»å¼·ã•ã‚’ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã§èª¿æ•´ã€‚</li>
          <li>ãƒ¢ãƒ¼ãƒ‰ã€Œãƒ¢ã‚¶ã‚¤ã‚¯ã€ã€Œæ¶ˆã—ã‚´ãƒ ï¼ˆåŸç”»ã«æˆ»ã™ï¼‰ã€ã‚‚åˆ©ç”¨å¯ã€‚</li>
          <li>ã§ããŸã‚‰ã€Œç”»åƒã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã¸ã€ã¾ãŸã¯ã€ŒPNGä¿å­˜ã€ã€‚</li>
        </ul>
        <div>âŒ¨ï¸ <b>ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ</b>ï¼š<br>
          <span class="kbd">[</span>/<span class="kbd">]</span> ãƒ–ãƒ©ã‚·Â±ã€
          <span class="kbd">âŒ˜/Ctrl+Z</span> Undoã€
          <span class="kbd">P</span> è²¼ä»˜ã€
          <span class="kbd">C</span> ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰æ›¸ãå‡ºã—ã€
          <span class="kbd">D</span> ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
        </div>
        <p class="ghost" style="margin-top:10px">â€» ãƒ–ãƒ©ã‚¦ã‚¶ã®åˆ¶é™ã§ã€ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰å…¥å‡ºåŠ›ã«ã¯è¨±å¯/ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œãŒå¿…è¦ã§ã™ã€‚Safariãªã©ä¸€éƒ¨ç’°å¢ƒã§ã¯ã€Œä¿å­˜ã€ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚</p>
      </div>
    </aside>

    <main>
      <canvas id="canvas" width="1280" height="800"></canvas>
    </main>
  </div>

  <footer>
    å®Œå…¨ãƒ­ãƒ¼ã‚«ãƒ«å‡¦ç†ï¼ˆã‚µãƒ¼ãƒãƒ¼é€ä¿¡ãªã—ï¼‰ã€‚ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼é…æ…®ã€‚
  </footer>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { willReadFrequently: false });
  const fileInput = document.getElementById('file');
  const pasteBtn = document.getElementById('pasteBtn');
  const openBtn = document.getElementById('openBtn');
  const copyBtn = document.getElementById('copyBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const undoBtn = document.getElementById('undoBtn');
  const resetBtn = document.getElementById('resetBtn');
  const brushSize = document.getElementById('brushSize');
  const brushSizeVal = document.getElementById('brushSizeVal');
  const blurRadius = document.getElementById('blurRadius');
  const blurVal = document.getElementById('blurVal');

  const modeRadios = [...document.querySelectorAll('input[name="mode"]')];
  const mode = () => modeRadios.find(r => r.checked)?.value || 'blur';

  let baseImage = null;              // åŸç”»åƒ
  let baseCanvas = document.createElement('canvas'); // åŸç”»åƒæç”»
  let blurCanvas = document.createElement('canvas'); // ã¼ã‹ã—å…¨ä½“ç‰ˆ
  let mosaicCanvas = document.createElement('canvas'); // ãƒ¢ã‚¶ã‚¤ã‚¯å…¨ä½“ç‰ˆ

  let strokes = []; // {points:[{x,y}], size, type:'blur'|'erase'|'pixelate'}
  let drawing = false;

  const setUIState = (ready) => {
    copyBtn.disabled = !ready;
    downloadBtn.disabled = !ready;
    resetBtn.disabled = !ready;
    undoBtn.disabled = !ready || strokes.length === 0;
  }

  function drawEmptyGuide(){
    ctx.save();
    ctx.fillStyle = '#0f131b';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.strokeStyle = '#2a3140';
    ctx.setLineDash([6,6]);
    ctx.strokeRect(16,16,canvas.width-32,canvas.height-32);
    ctx.fillStyle = '#a9b0be';
    ctx.font = '14px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.textAlign = 'center';
    ctx.fillText('ã“ã“ã«ç”»åƒã‚’è²¼ã‚Šä»˜ã‘ï¼ˆâŒ˜/Ctrl+Vï¼‰ã¾ãŸã¯ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—', canvas.width/2, canvas.height/2);
    ctx.restore();
    setUIState(false);
  }
  drawEmptyGuide();

  async function loadImageFromBlob(blob){
    const img = new Image();
    img.src = URL.createObjectURL(blob);
    await img.decode();

    const maxW = Math.min(4096, img.naturalWidth);
    const maxH = Math.min(4096, img.naturalHeight);
    canvas.width = maxW; canvas.height = Math.round(img.naturalHeight * (maxW / img.naturalWidth));
    if (canvas.height > maxH) { canvas.height = maxH; canvas.width = Math.round(img.naturalWidth * (maxH / img.naturalHeight)); }

    baseCanvas.width = canvas.width; baseCanvas.height = canvas.height;
    const bctx = baseCanvas.getContext('2d');
    bctx.drawImage(img, 0, 0, baseCanvas.width, baseCanvas.height);

    blurCanvas.width = canvas.width; blurCanvas.height = canvas.height;
    const blctx = blurCanvas.getContext('2d');
    blctx.filter = `blur(${Number(blurRadius.value)}px)`;
    blctx.drawImage(baseCanvas, 0, 0);

    mosaicCanvas.width = canvas.width; mosaicCanvas.height = canvas.height;
    const mctx = mosaicCanvas.getContext('2d');
    const tile = Math.max(4, Math.floor(Number(blurRadius.value) * 1.2));
    const smallW = Math.max(1, Math.floor(canvas.width / tile));
    const smallH = Math.max(1, Math.floor(canvas.height / tile));
    const tmp = document.createElement('canvas'); tmp.width = smallW; tmp.height = smallH;
    const tctx = tmp.getContext('2d', { willReadFrequently: false, alpha: false });
    tctx.imageSmoothingEnabled = false;
    tctx.drawImage(baseCanvas, 0,0, smallW, smallH);
    mctx.imageSmoothingEnabled = false;
    mctx.drawImage(tmp, 0,0, smallW, smallH, 0,0, canvas.width, canvas.height);

    baseImage = img; strokes = [];
    redraw();
    setUIState(true);
  }

  function redraw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(baseCanvas, 0, 0);

    for(const s of strokes){
      const src = s.type === 'erase' ? baseCanvas : (s.type === 'pixelate' ? mosaicCanvas : blurCanvas);
      ctx.save();
      ctx.beginPath();
      for(const p of s.points){ ctx.moveTo(p.x, p.y); ctx.arc(p.x, p.y, s.size/2, 0, Math.PI*2); }
      ctx.clip('nonzero');
      ctx.drawImage(src, 0, 0);
      ctx.restore();
    }
  }

  function startStroke(x,y){ drawing = true; strokes.push({ type: mode(), size: Number(brushSize.value), points: [{x,y}] }); redraw(); setUIState(true); }
  function extendStroke(x,y){ if(!drawing) return; const s = strokes[strokes.length-1]; s.points.push({x,y}); redraw(); }
  function endStroke(){ drawing = false; setUIState(true); }

  function getXY(evt){
    const rect = canvas.getBoundingClientRect();
    let cx, cy;
    if (evt.touches && evt.touches[0]) { cx = evt.touches[0].clientX; cy = evt.touches[0].clientY; }
    else { cx = evt.clientX; cy = evt.clientY; }
    const x = (cx - rect.left) * (canvas.width / rect.width);
    const y = (cy - rect.top) * (canvas.height / rect.height);
    return {x, y};
  }

  canvas.addEventListener('mousedown', e => { if(!baseImage) return; const {x,y}=getXY(e); startStroke(x,y); });
  canvas.addEventListener('mousemove', e => { if(!baseImage) return; const {x,y}=getXY(e); extendStroke(x,y); });
  window.addEventListener('mouseup', () => endStroke());

  canvas.addEventListener('touchstart', e => { if(!baseImage) return; e.preventDefault(); const {x,y}=getXY(e); startStroke(x,y); }, {passive:false});
  canvas.addEventListener('touchmove', e => { if(!baseImage) return; e.preventDefault(); const {x,y}=getXY(e); extendStroke(x,y); }, {passive:false});
  canvas.addEventListener('touchend', () => endStroke());

  canvas.addEventListener('dragover', e => { e.preventDefault(); });
  canvas.addEventListener('drop', e => { e.preventDefault(); const f = e.dataTransfer.files?.[0]; if(f) loadImageFromBlob(f); });

  brushSize.addEventListener('input', () => { brushSizeVal.textContent = `${brushSize.value} px`; });
  blurRadius.addEventListener('input', () => { blurVal.textContent = `${blurRadius.value} px`; if(baseImage) rebuildEffects(); });
  modeRadios.forEach(r => r.addEventListener('change', () => {/* no-op */}));

  function rebuildEffects(){
    blurCanvas.width = canvas.width; blurCanvas.height = canvas.height;
    const blctx = blurCanvas.getContext('2d');
    blctx.filter = `blur(${Number(blurRadius.value)}px)`;
    blctx.drawImage(baseCanvas, 0, 0);

    mosaicCanvas.width = canvas.width; mosaicCanvas.height = canvas.height;
    const mctx = mosaicCanvas.getContext('2d');
    const tile = Math.max(4, Math.floor(Number(blurRadius.value) * 1.2));
    const smallW = Math.max(1, Math.floor(canvas.width / tile));
    const smallH = Math.max(1, Math.floor(canvas.height / tile));
    const tmp = document.createElement('canvas'); tmp.width = smallW; tmp.height = smallH;
    const tctx = tmp.getContext('2d');
    tctx.imageSmoothingEnabled = false;
    tctx.drawImage(baseCanvas, 0,0, smallW, smallH);
    mctx.imageSmoothingEnabled = false;
    mctx.drawImage(tmp, 0,0, smallW, smallH, 0,0, canvas.width, canvas.height);
    redraw();
  }

  openBtn.addEventListener('click', () => fileInput.click());
  fileInput.addEventListener('change', () => { const f=fileInput.files?.[0]; if(f) loadImageFromBlob(f); });

  pasteBtn.addEventListener('click', async () => {
    try {
      if (navigator.clipboard?.read) {
        const items = await navigator.clipboard.read();
        for (const item of items) {
          const type = item.types.find(t => t.startsWith('image/'));
          if (type) { const blob = await item.getType(type); await loadImageFromBlob(blob); return; }
        }
        alert('ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ç”»åƒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆå¾Œã«ãŠè©¦ã—ãã ã•ã„ã€‚');
      } else {
        alert('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ç”»åƒã®è²¼ã‚Šä»˜ã‘APIã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚Ctrl/âŒ˜+Vã‚’ãŠè©¦ã—ãã ã•ã„ã€‚');
      }
    } catch (e) { console.error(e); alert('è²¼ã‚Šä»˜ã‘ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆæ¨©é™ãŒå¿…è¦ãªå ´åˆãŒã‚ã‚Šã¾ã™ï¼‰ã€‚'); }
  });

  window.addEventListener('paste', async (e) => {
    const item = [...e.clipboardData.items].find(i => i.type.startsWith('image/'));
    if(item){ e.preventDefault(); const blob = item.getAsFile(); if(blob) await loadImageFromBlob(blob); }
  });

  copyBtn.addEventListener('click', async () => {
    try {
      const blob = await new Promise(res => canvas.toBlob(res, 'image/png'));
      if (!blob) throw new Error('toBlob failed');
      if (navigator.clipboard?.write) {
        await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
        copyBtn.textContent = 'âœ… ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ';
        setTimeout(()=> copyBtn.textContent = 'ğŸ“¤ ç”»åƒã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã¸ âŒ˜/Ctrl+C', 1000);
      } else {
        alert('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ç”»åƒã®ã‚³ãƒ”ãƒ¼APIã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚PNGä¿å­˜ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚');
      }
    } catch (e){ console.error(e); alert('ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã¸ã®æ›¸ãå‡ºã—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚'); }
  });

  downloadBtn.addEventListener('click', () => {
    const a = document.createElement('a');
    a.download = 'blurred.png';
    a.href = canvas.toDataURL('image/png');
    a.click();
  });

  undoBtn.addEventListener('click', () => { strokes.pop(); redraw(); setUIState(true); });
  resetBtn.addEventListener('click', () => { if(!baseImage) return; strokes=[]; redraw(); setUIState(true); });

  window.addEventListener('keydown', (e) => {
    if(e.key === '['){ brushSize.value = Math.max(6, Number(brushSize.value) - 2); brushSize.dispatchEvent(new Event('input')); }
    if(e.key === ']'){ brushSize.value = Math.min(200, Number(brushSize.value) + 2); brushSize.dispatchEvent(new Event('input')); }
    if((e.metaKey||e.ctrlKey) && e.key.toLowerCase()==='z'){ e.preventDefault(); undoBtn.click(); }
    if(e.key.toLowerCase()==='p'){ pasteBtn.click(); }
    if(e.key.toLowerCase()==='c'){ copyBtn.click(); }
    if(e.key.toLowerCase()==='d'){ downloadBtn.click(); }
  });
})();
</script>

<script>
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("./sw.js");
    });
  }
</script>
</body>
</html>
